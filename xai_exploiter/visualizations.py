"""
SHAP Visualizations Module
Author: Roshan Raundal
Date: September 2025
Purpose: Comprehensive visualization functions for SHAP explanations
"""

import os
from typing import Union, Optional, Dict, Any, List

import numpy as np
import pandas as pd
import shap
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objects as go

# NOTE: seaborn is imported to allow user style choices; plotly for interactive plots


class SHAPVisualizer:
    """
    Comprehensive SHAP visualization class with multiple plot types
    and export capabilities
    """

    def __init__(self, style: str = "seaborn", figsize: tuple = (12, 8)):
        """
        Initialize visualizer

        Args:
            style: Matplotlib style ('seaborn', 'ggplot', 'default')
            figsize: Default figure size
        """
        self.style = style
        self.figsize = figsize

        # Set matplotlib style robustly
        try:
            if style == "seaborn":
                plt.style.use("seaborn-v0_8")
            else:
                plt.style.use(style)
        except Exception:
            # fallback to default if style not available
            plt.style.use("default")

        # Initialize SHAP JS support for interactive plots in notebooks
        try:
            shap.initjs()
        except Exception:
            # Not critical; interactive plots may not render outside notebooks
            print("‚ö†Ô∏è JavaScript initialization failed. Some interactive plots may not work.")

    def waterfall_plot(
        self,
        explanation_result: Dict[str, Any],
        max_display: int = 10,
        save_path: Optional[str] = None,
        title: str = "SHAP Waterfall Plot"
    ) -> plt.Figure:
        """
        Create waterfall plot for individual instance explanation

        Args:
            explanation_result: Result from SHAPExplainer.explain_instance() or similar.
                Expected keys: 'shap_values', 'expected_value', 'prediction', 'instance', optional 'feature_names'
            max_display: Maximum number of features to display
            save_path: Path to save the plot
            title: Plot title

        Returns:
            Matplotlib figure
        """
        # Create figure
        fig, ax = plt.subplots(figsize=self.figsize)

        # Safe extraction and casting to avoid boolean/shape ambiguities
        shap_values = np.array(explanation_result.get('shap_values', []))
        expected_value = float(explanation_result.get('expected_value', 0.0))
        prediction = float(explanation_result.get('prediction', expected_value))
        feature_names = explanation_result.get('feature_names', None)

        # Get instance values safely
        instance_raw = explanation_result.get('instance', None)
        if isinstance(instance_raw, pd.DataFrame):
            # take first row if DataFrame
            instance_values = instance_raw.iloc[0].values
        elif isinstance(instance_raw, (pd.Series, list, tuple, np.ndarray)):
            instance_values = np.array(instance_raw).flatten()
        else:
            # fallback: empty array
            instance_values = np.array([])

        # Ensure feature_names is a safe python list if present
        if feature_names is None or (
            isinstance(feature_names, (list, tuple)) and len(feature_names) == 0
        ) or (isinstance(feature_names, np.ndarray) and feature_names.size == 0):
            # fallback feature names
            # if shap_values is 2D (e.g., multiclass), use the second dim length or instance length
            try:
                length = shap_values.shape[-1]
                if length == 0:
                    length = instance_values.shape[0] if instance_values.size > 0 else 0
            except Exception:
                length = instance_values.shape[0] if instance_values.size > 0 else 0
            feature_names = [f'Feature_{i}' for i in range(length)]

        # If shap_values is multi-dimensional (e.g., multiclass where shap_values is list/2D),
        # try to reduce to 1D for waterfall (use first class by default)
        if shap_values.ndim > 1:
            # select the first output's shap values to plot for instance-level waterfall
            shap_arr = shap_values[0] if shap_values.shape[0] > 0 else shap_values
            shap_values_1d = np.array(shap_arr).flatten()
        else:
            shap_values_1d = shap_values.flatten()

        # guard max_display vs available features
        n_features_available = shap_values_1d.size
        if n_features_available == 0:
            raise ValueError("No SHAP values available in explanation_result['shap_values'].")

        max_display = min(int(max_display), n_features_available)

        # Sort by absolute SHAP value descending, pick top indices
        indices = np.argsort(np.abs(shap_values_1d))[::-1][:max_display]

        # Build cumulative values for waterfall bars
        cumulative = [expected_value]
        for idx in indices:
            cumulative.append(cumulative[-1] + float(shap_values_1d[idx]))

        # Colors: base, positive (red), negative (blue), final (darkgreen)
        colors = ['lightblue'] + ['red' if shap_values_1d[idx] > 0 else 'blue' for idx in indices] + ['darkgreen']

        # Base value
        ax.bar(0, expected_value, color=colors[0], label='Base Value')

        # Feature contributions
        for i, idx in enumerate(indices):
            height = float(shap_values_1d[idx])
            # bottom: start of bar. If positive contribution, bar stacks on cumulative[i]; if negative, it starts at cumulative[i] + height
            bottom = cumulative[i] if height > 0 else cumulative[i] + height
            # width is abs(height)
            ax.bar(i + 1, abs(height), bottom=bottom, color=colors[i + 1],
                   label=f"{feature_names[idx]} = {instance_values[idx]:.3f}" if instance_values.size > idx else f"{feature_names[idx]}")

        # Final prediction bar
        ax.bar(len(indices) + 1, prediction, color=colors[-1], label='Prediction')

        # Customization
        ax.set_xlabel('Features')
        ax.set_ylabel('Output')
        ax.set_title(title)
        x_pos = list(range(len(indices) + 2))
        xticklabels = ['Base'] + [feature_names[idx] for idx in indices] + ['Prediction']
        ax.set_xticks(x_pos)
        ax.set_xticklabels(xticklabels, rotation=45, ha='right')
        ax.legend(loc='upper right', fontsize='small', framealpha=0.7)

        plt.tight_layout()

        if save_path:
            try:
                plt.savefig(save_path, dpi=300, bbox_inches='tight')
                print(f"üíæ Waterfall plot saved to {save_path}")
            except Exception as e:
                print(f"‚ùå Could not save waterfall plot to {save_path}: {e}")

        return fig

    def summary_plot(
        self,
        shap_values: np.ndarray,
        features: Union[np.ndarray, pd.DataFrame],
        feature_names: Optional[List[str]] = None,
        plot_type: str = "dot",
        max_display: int = 20,
        save_path: Optional[str] = None,
        title: str = "SHAP Summary Plot"
    ) -> None:
        """
        Create SHAP summary plot (beeswarm or bar plot)

        Args:
            shap_values: SHAP values array
            features: Feature values (array or DataFrame)
            feature_names: Feature names (optional)
            plot_type: 'dot' for beeswarm, 'bar' for bar plot
            max_display: Maximum features to display
            save_path: Path to save plot
            title: Plot title
        """
        plt.figure(figsize=self.figsize)

        # Validate inputs and avoid ambiguous truth-testing on numpy arrays
        try:
            # Call SHAP's built-in summary_plot
            shap.summary_plot(
                shap_values,
                features,
                feature_names=feature_names,
                plot_type=plot_type,
                max_display=int(max_display),
                show=False
            )
            plt.title(title)

            if save_path:
                try:
                    plt.savefig(save_path, dpi=300, bbox_inches='tight')
                    print(f"üíæ Summary plot saved to {save_path}")
                except Exception as e:
                    print(f"‚ùå Could not save summary plot to {save_path}: {e}")

            plt.show()

        except Exception as e:
            print(f"‚ùå Error creating summary plot: {e}")

    def force_plot_html(
        self,
        explanation_result: Dict[str, Any],
        save_path: Optional[str] = None
    ) -> str:
        """
        Generate HTML for interactive force plot

        Args:
            explanation_result: Result from explain_instance()
            save_path: Path to save HTML

        Returns:
            HTML string
        """
        try:
            shap_values = explanation_result.get('shap_values', None)
            expected_value = explanation_result.get('expected_value', None)
            feature_names = explanation_result.get('feature_names', None)
            instance_raw = explanation_result.get('instance', None)

            if shap_values is None or expected_value is None or instance_raw is None:
                raise ValueError("explanation_result must contain 'shap_values', 'expected_value' and 'instance' keys")

            # Convert values safely
            shap_values_arr = np.array(shap_values)
            expected_value_f = float(expected_value)

            # Get instance as a pandas Series for nicer labels if possible
            if isinstance(instance_raw, pd.DataFrame):
                instance_series = instance_raw.iloc[0]
            elif isinstance(instance_raw, (pd.Series, list, tuple, np.ndarray)):
                inst_vals = np.array(instance_raw).flatten()
                if feature_names is not None:
                    # Align names to values
                    try:
                        instance_series = pd.Series(inst_vals, index=feature_names)
                    except Exception:
                        instance_series = pd.Series(inst_vals)
                else:
                    instance_series = pd.Series(inst_vals)
            else:
                instance_series = pd.Series([])

            # For interactive force plot, shap expects (base_value, shap_values, features)
            # If shap_values_arr is multidimensional (multiclass), choose first output
            if shap_values_arr.ndim > 1:
                shap_values_for_plot = shap_values_arr[0]
            else:
                shap_values_for_plot = shap_values_arr

            # Create force plot object
            # Note: shap.force_plot returns a JS powered object in notebooks; use HTML repr to store
            force_plot_obj = shap.force_plot(
                expected_value_f,
                shap_values_for_plot,
                instance_series,
                feature_names=feature_names
            )

            html = force_plot_obj._repr_html_()

            if save_path:
                try:
                    with open(save_path, 'w', encoding='utf-8') as f:
                        f.write(html)
                    print(f"üíæ Interactive force plot saved to {save_path}")
                except Exception as e:
                    print(f"‚ùå Could not save force plot HTML to {save_path}: {e}")

            return html

        except Exception as e:
            print(f"‚ùå Error creating force plot: {e}")
            return ""

    def feature_importance_plot(
        self,
        importance_df: pd.DataFrame,
        top_n: int = 15,
        save_path: Optional[str] = None,
        title: str = "Feature Importance (SHAP)"
    ) -> plt.Figure:
        """
        Create feature importance bar plot

        Args:
            importance_df: DataFrame with 'feature' and 'importance' columns
            top_n: Number of top features to show
            save_path: Path to save plot
            title: Plot title

        Returns:
            Matplotlib figure
        """
        fig, ax = plt.subplots(figsize=self.figsize)

        # Defensive handling of importance_df
        if not isinstance(importance_df, pd.DataFrame):
            raise ValueError("importance_df must be a pandas DataFrame with 'feature' and 'importance' columns")

        # Sort and select top_n
        importance_df_sorted = importance_df.sort_values('importance', ascending=False).reset_index(drop=True)
        top_features = importance_df_sorted.head(int(top_n))

        # Horizontal bar plot
        bars = ax.barh(range(len(top_features)), top_features['importance'],
                       color='steelblue', alpha=0.7)

        ax.set_yticks(range(len(top_features)))
        ax.set_yticklabels(top_features['feature'])
        ax.set_xlabel('Mean |SHAP Value|')
        ax.set_title(title)
        ax.grid(axis='x', alpha=0.3)

        # Value labels on bars
        for i, (bar, value) in enumerate(zip(bars, top_features['importance'])):
            ax.text(bar.get_width() + 0.01, bar.get_y() + bar.get_height() / 2,
                    f'{value:.4f}', va='center', ha='left', fontsize=10)

        plt.tight_layout()

        if save_path:
            try:
                plt.savefig(save_path, dpi=300, bbox_inches='tight')
                print(f"üíæ Feature importance plot saved to {save_path}")
            except Exception as e:
                print(f"‚ùå Could not save feature importance plot to {save_path}: {e}")

        return fig

    def dependence_plot(
        self,
        shap_values: np.ndarray,
        features: Union[np.ndarray, pd.DataFrame],
        feature_idx: Union[int, str],
        interaction_feature: Optional[Union[int, str]] = None,
        feature_names: Optional[List[str]] = None,
        save_path: Optional[str] = None,
        title: Optional[str] = None
    ) -> None:
        """
        Create SHAP dependence plot

        Args:
            shap_values: SHAP values array
            features: Feature values
            feature_idx: Index or name of main feature
            interaction_feature: Index or name of interaction feature
            feature_names: Feature names
            save_path: Path to save plot
            title: Plot title
        """
        plt.figure(figsize=self.figsize)

        try:
            shap.dependence_plot(
                feature_idx,
                shap_values,
                features,
                feature_names=feature_names,
                interaction_index=interaction_feature,
                show=False
            )

            if title:
                plt.title(title)

            if save_path:
                try:
                    plt.savefig(save_path, dpi=300, bbox_inches='tight')
                    print(f"üíæ Dependence plot saved to {save_path}")
                except Exception as e:
                    print(f"‚ùå Could not save dependence plot to {save_path}: {e}")

            plt.show()

        except Exception as e:
            print(f"‚ùå Error creating dependence plot: {e}")

    def decision_plot(
        self,
        expected_value: float,
        shap_values: np.ndarray,
        features: Union[np.ndarray, pd.DataFrame],
        feature_names: Optional[List[str]] = None,
        highlight: Optional[int] = None,
        save_path: Optional[str] = None,
        title: str = "SHAP Decision Plot"
    ) -> None:
        """
        Create SHAP decision plot

        Args:
            expected_value: Base/expected value
            shap_values: SHAP values
            features: Feature values
            feature_names: Feature names
            highlight: Index of instance to highlight
            save_path: Path to save plot
            title: Plot title
        """
        plt.figure(figsize=self.figsize)

        try:
            shap.decision_plot(
                expected_value,
                shap_values,
                features,
                feature_names=feature_names,
                highlight=highlight,
                show=False
            )
            plt.title(title)

            if save_path:
                try:
                    plt.savefig(save_path, dpi=300, bbox_inches='tight')
                    print(f"üíæ Decision plot saved to {save_path}")
                except Exception as e:
                    print(f"‚ùå Could not save decision plot to {save_path}: {e}")

            plt.show()

        except Exception as e:
            print(f"‚ùå Error creating decision plot: {e}")

    def create_plotly_importance(
        self,
        importance_df: pd.DataFrame,
        top_n: int = 15,
        title: str = "Interactive Feature Importance"
    ) -> go.Figure:
        """
        Create interactive Plotly feature importance plot

        Args:
            importance_df: DataFrame with feature importance
            top_n: Number of top features
            title: Plot title

        Returns:
            Plotly figure
        """
        if not isinstance(importance_df, pd.DataFrame):
            raise ValueError("importance_df must be a pandas DataFrame")

        top_features = importance_df.sort_values('importance', ascending=False).head(int(top_n))

        fig = go.Figure()

        fig.add_trace(go.Bar(
            y=top_features['feature'],
            x=top_features['importance'],
            orientation='h',
            marker=dict(color='steelblue', opacity=0.7),
            text=[f'{val:.4f}' for val in top_features['importance']],
            textposition='outside'
        ))

        fig.update_layout(
            title=title,
            xaxis_title='Mean |SHAP Value|',
            yaxis_title='Features',
            height=max(400, int(top_n) * 25),
            margin=dict(l=200)
        )

        return fig

    def generate_report(
        self,
        explainer_results: Dict[str, Any],
        save_dir: str = "./shap_report"
    ) -> str:
        """
        Generate comprehensive SHAP analysis report

        Args:
            explainer_results: Results from SHAPExplainer
                Expected keys optionally:
                    - 'feature_importance' : list or array of importances (mean |shap|)
                    - 'feature_names' : list of feature names
                    - 'shap_values' : shap values array
                    - 'data' : features array or DataFrame corresponding to shap_values
            save_dir: Directory to save report files

        Returns:
            Path to HTML report
        """
        os.makedirs(save_dir, exist_ok=True)

        plots_generated = []

        try:
            # Feature importance plot
            if 'feature_importance' in explainer_results and explainer_results['feature_importance'] is not None:
                # Build DataFrame
                fnames = explainer_results.get('feature_names', None)
                importance_arr = np.array(explainer_results['feature_importance']).flatten()
                if fnames is None:
                    fnames = [f'Feature_{i}' for i in range(importance_arr.size)]
                importance_df = pd.DataFrame({
                    'feature': fnames,
                    'importance': importance_arr
                })
                importance_df = importance_df.sort_values('importance', ascending=False).reset_index(drop=True)

                importance_path = os.path.join(save_dir, 'feature_importance.png')
                self.feature_importance_plot(importance_df, save_path=importance_path)
                plots_generated.append(('Feature Importance', 'feature_importance.png'))

            # Summary plot
            if 'shap_values' in explainer_results and 'data' in explainer_results:
                summary_path = os.path.join(save_dir, 'summary_plot.png')
                self.summary_plot(
                    explainer_results['shap_values'],
                    explainer_results['data'],
                    feature_names=explainer_results.get('feature_names', None),
                    save_path=summary_path
                )
                plots_generated.append(('Summary Plot', 'summary_plot.png'))

            # Optional: force plot for a single instance (if provided)
            if 'shap_values' in explainer_results and 'instance' in explainer_results and 'expected_value' in explainer_results:
                force_html_path = os.path.join(save_dir, 'force_plot.html')
                html_content = self.force_plot_html({
                    'shap_values': explainer_results['shap_values'],
                    'expected_value': explainer_results['expected_value'],
                    'instance': explainer_results['instance'],
                    'feature_names': explainer_results.get('feature_names', None)
                }, save_path=force_html_path)
                if html_content:
                    plots_generated.append(('Force Plot (interactive)', 'force_plot.html'))

            # Build HTML content
            html_content = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>SHAP Analysis Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; background: #ffffff; color: #222; }}
        .header {{ background-color: #f8f9fa; padding: 20px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }}
        .section {{ margin: 30px 0; }}
        .plot {{ text-align: center; margin: 20px 0; }}
        img {{ max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 8px; }}
        .note {{ color: #666; font-size: 0.9rem; }}
        .small {{ font-size: 0.85rem; color: #444; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>üîç SHAP Analysis Report</h1>
        <p><strong>Generated by:</strong> Roshan Raundal - XAI Exploiter</p>
        <p class="small"><strong>Date:</strong> {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>
    <div class="section">
        <h2>üìä Analysis Summary</h2>
        <p class="note">This report contains SHAP (SHapley Additive exPlanations) analysis visuals generated automatically.</p>
    </div>
"""

            for plot_title, plot_file in plots_generated:
                # if plot_file exists in save_dir include it, else skip
                safe_path = os.path.join(save_dir, plot_file)
                if os.path.exists(safe_path):
                    # If html file, embed link; if png, embed image
                    if plot_file.lower().endswith('.html'):
                        html_content += f"""
    <div class="section">
        <h3>{plot_title}</h3>
        <div class="plot">
            <iframe src="{plot_file}" style="width:100%; height:600px; border: none;"></iframe>
        </div>
    </div>
"""
                    else:
                        html_content += f"""
    <div class="section">
        <h3>{plot_title}</h3>
        <div class="plot">
            <img src="{plot_file}" alt="{plot_title}">
        </div>
    </div>
"""
                else:
                    # Skip missing files silently
                    continue

            html_content += """
</body>
</html>
"""

            report_path = os.path.join(save_dir, 'shap_report.html')
            try:
                with open(report_path, 'w', encoding='utf-8') as f:
                    f.write(html_content)
                print(f"üìù Comprehensive SHAP report generated: {report_path}")
                return report_path
            except Exception as e:
                print(f"‚ùå Could not write report HTML to {report_path}: {e}")
                return ""

        except Exception as e:
            print(f"‚ùå Error generating report: {e}")
            return ""

# Utility functions for quick plotting (keeps parity with original API)
def quick_waterfall(explanation_result: Dict[str, Any], **kwargs):
    """Quick waterfall plot generation"""
    visualizer = SHAPVisualizer()
    return visualizer.waterfall_plot(explanation_result, **kwargs)


def quick_summary(shap_values, features, **kwargs):
    """Quick summary plot generation"""
    visualizer = SHAPVisualizer()
    visualizer.summary_plot(shap_values, features, **kwargs)


def quick_importance(importance_df: pd.DataFrame, **kwargs):
    """Quick importance plot generation"""
    visualizer = SHAPVisualizer()
    return visualizer.feature_importance_plot(importance_df, **kwargs)


if __name__ == "__main__":
    print("üé® SHAP Visualizations module loaded successfully!")
    print("üìä Use: visualizer = SHAPVisualizer() to get started")
